<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: #000;
            position: relative;
        }

        .canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 10px;
            /* image-rendering: pixelated; */

        }
        
        .canvas-terrain {
            box-sizing: border-box;
            /* box-shadow: 0 0 0 2px black; */
            border: 4px solid rgb(87 83 78);
            /* image-rendering: pixelated; */
        }

        .debug-buttons {
            position: absolute;
            bottom: 0;
            left: 0;
        }

    </style>
    <title>Document</title>
  <script type="module" crossorigin>
var j=Object.defineProperty;var G=(f,t,e)=>t in f?j(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e;var a=(f,t,e)=>(G(f,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const r of o.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&i(r)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}})();class D{static renderLine(t,e,i,s="red",o=1){t.beginPath(),t.moveTo(e[0],e[1]),t.lineTo(i[0],i[1]),t.lineWidth=o,t.fillStyle=s,t.strokeStyle=s,t.stroke()}static renderCircle(t,e,i,s,o=1){t.beginPath(),t.arc(e[0],e[1],i,0,2*Math.PI),t.fillStyle=s,t.strokeStyle="black",t.lineWidth=o,t.fill(),t.stroke()}static renderText(t,e,i,s="center",o=50,r="black"){t.font=`${o}px sans-serif`,t.textAlign=s,t.textBaseline="middle",t.fillStyle=r,t.fillText(e,i[0],i[1])}}const u=class u{static lineCircle(t,e,i,s){const o=u.relativeVector(t,e),r=u.len(o),n=((i[0]-t[0])*(e[0]-t[0])+(i[1]-t[1])*(e[1]-t[1]))/Math.pow(r,2),l=[t[0]+n*(e[0]-t[0]),t[1]+n*(e[1]-t[1])],h=u.linePoint(t,e,l),p=u.distance(l,i)<=s&&h;if(!p){if(u.pointCircle(t,i,s))return[!0,t,u.lookAtDirection(t,i)];if(u.pointCircle(e,i,s))return[!0,e,u.lookAtDirection(e,i)]}return[p,l,u.lookAtDirection(l,i)]}static linePoint(t,e,i){const s=u.distance(i,t),o=u.distance(i,e),r=u.distance(t,e),n=5;return s+o>=r-n&&s+o<=r+n}};a(u,"add",(t,e)=>[t[0]+e[0],t[1]+e[1]]),a(u,"subtract",(t,e)=>[t[0]-e[0],t[1]-e[1]]),a(u,"multiply",(t,e)=>[t[0]*e[0],t[1]*e[1]]),a(u,"divide",(t,e)=>[t[0]/e[0],t[1]/e[1]]),a(u,"multiplyBy",(t,e)=>[t[0]*e,t[1]*e]),a(u,"divideBy",(t,e)=>[t[0]/e,t[1]/e]),a(u,"addAll",(...t)=>t.reduce((e,i)=>u.add(e,i),[0,0])),a(u,"multiplyAll",(...t)=>t.reduce((e,i)=>[e[0]*i[0],e[1]*i[1]],[1,1])),a(u,"relativeVector",(t,e)=>[t[0]-e[0],t[1]-e[1]]),a(u,"negate",t=>[-t[0],-t[1]]),a(u,"interp",(t,e,i)=>[t[0]+(e[0]-t[0])*i,t[1]+(e[1]-t[1])*i]),a(u,"floor",t=>[Math.floor(t[0]),Math.floor(t[1])]),a(u,"round",t=>[Math.round(t[0]),Math.round(t[1])]),a(u,"distance",(t,e)=>{const i=u.relativeVector(t,e);return Math.hypot(i[0],i[1])}),a(u,"normalize",t=>{const e=Math.hypot(t[0],t[1]);return e?[t[0]/e,t[1]/e]:t}),a(u,"rotate",(t,e)=>{e=-e*(Math.PI/180);const i=Math.cos(e),s=Math.sin(e);return[Math.round(1e4*(t[0]*i-t[1]*s))/1e4,Math.round(1e4*(t[0]*s+t[1]*i))/1e4]}),a(u,"dot",(t,e)=>t[0]*e[0]+t[1]*e[1]),a(u,"cross",(t,e)=>(t[2]=0,e[2]=0,[t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]])),a(u,"equals",(t,e)=>t[0]===e[0]&&t[1]===e[1]),a(u,"len",t=>Math.sqrt(u.dot(t,t))),a(u,"min",(t,e)=>{const i=Math.min(t[0],e[0]),s=Math.min(t[1],e[1]);return[i,s]}),a(u,"max",(t,e)=>{const i=Math.max(t[0],t[0]),s=Math.max(t[1],e[1]);return[i,s]}),a(u,"lookAtDirection",(t,e)=>u.normalize(u.relativeVector(t,e))),a(u,"perpendicular",t=>[t[0],-t[1]]),a(u,"reflection",(t,e)=>u.subtract(t,u.multiplyBy(e,2*u.dot(t,e)))),a(u,"project",(t,e,i)=>{const s=u.subtract(i,e),o=u.subtract(t,e),r=u.dot(o,s),n=u.dot(s,s),l=r/n;return u.add(e,u.multiplyBy(s,l))}),a(u,"pointCircle",(t,e,i)=>u.distance(t,e)<=i);let c=u;class N{constructor(t,e,i,s=[0,0]){a(this,"ctx");a(this,"input");a(this,"prevInput");a(this,"lastActualInput");a(this,"prevVelocity");a(this,"face");a(this,"angle");a(this,"pos");a(this,"radius");a(this,"velocity");a(this,"maxVelocityLength");a(this,"inputVelocityLength");a(this,"isFalling");a(this,"numFramesFalling");a(this,"airControl");a(this,"elasticity");a(this,"gravityVector");a(this,"airDrag");a(this,"groundFriction");a(this,"queue");a(this,"mode");a(this,"collisionPoint");a(this,"collisionNormal");a(this,"gradientBody");a(this,"world");a(this,"render",t=>{if(this.world.input._mappings.jump.active&&this.mode!=="dig"){const o=c.add(this.pos,[this.input[0]*-5,Math.min(Math.max(this.radius+this.velocity[1]*-5,25),35)]);D.renderLine(t,c.add(this.pos,[0,this.radius]),o,"red",7)}t.translate(this.pos[0],this.pos[1]),D.renderCircle(t,[0,0],this.radius,this.gradientBody),t.setTransform(1,0,0,1,0,0),this.isFalling;const e=c.dot(c.normalize(this.input),c.normalize(this.prevInput));e<=0&&c.len(this.input)&&(console.log("turn around",e),this.face=this.input[0]>0?"right":"left",this.prevInput=this.input);const i=c.rotate([this.face==="left"?-this.radius:this.radius,0],this.face==="left"?this.angle:-this.angle),s=c.add(this.pos,c.multiplyBy(i,1));this.mode==="dig"?D.renderCircle(t,s,5,this.world.input._mappings.jump.active?"red":"salmon"):D.renderCircle(t,s,5,"wheat"),this.queue.forEach(o=>o(t)),this.queue=[]});a(this,"update",t=>{if(t&&this.queue.push(r=>D.renderText(r,`fps: ${(1/t).toFixed(1)}`,[20,20],"left",18)),this.world.input._mappings.moveUp.active?this.angle=Math.min(Math.max(this.angle-150*t,-90),90):this.world.input._mappings.moveDown.active&&(this.angle=Math.min(Math.max(this.angle+150*t,-90),90)),this.world.input._mappings.jump.active)if(this.mode==="dig"){this.world.sculpComponent.strength=(this.world.input._mappings.shift.active?75:-75)*t,this.world.sculpComponent.radiusXY=3;const r=c.rotate([this.face==="left"?-this.radius:this.radius,0],this.face==="left"?this.angle:-this.angle),n=c.add(this.pos,c.multiplyBy(r,2));this.world.sculpComponent.sculpt(n)}else{const r=this.velocity[1]<=-2.5;this.velocity=c.add(this.velocity,[0,-this.gravityVector[1]*(r?1.2:1.8)*t])}this.velocity[0]*=this.airDrag,this.velocity[1]*=this.airDrag,this.velocity[0]+=this.gravityVector[0]*t,this.velocity[1]+=this.gravityVector[1]*t;let e=c.len(this.velocity),i=c.len(c.subtract(this.velocity,this.gravityVector)),s=c.len(c.subtract(this.prevVelocity,this.gravityVector));const o=e/this.maxVelocityLength;o>1?(console.log("velocity length too large. Clamped to max value...",e),this.velocity=c.divideBy(this.velocity,o)):s>1&&Math.abs(i)<=.05&&Math.abs(c.distance(this.prevVelocity,this.velocity))<=.001&&(console.log("velocity too small, setting to zero...",i),this.velocity=[0,0]),this.pos[0]+=this.velocity[0],this.pos[1]+=this.velocity[1],this.prevVelocity=this.velocity,this.addInput(t),this.collision()});this.ctx=t.ctx,this.world=t,this.input=e,this.prevInput=e,this.lastActualInput=e,this.prevVelocity=[0,0],this.face="left",this.angle=0,this.pos=i,this.radius=20,this.velocity=s,this.maxVelocityLength=35,this.inputVelocityLength=30,this.isFalling=!0,this.numFramesFalling=0,this.airControl=.3,this.elasticity=.4,this.gravityVector=[0,30],this.airDrag=.98,this.groundFriction=.92,this.queue=[],this.mode="normal",this.collisionPoint=null,this.collisionNormal=null,this.gradientBody=t.ctx.createRadialGradient(5,this.radius/-3,2,0,0,this.radius-5),this.gradientBody.addColorStop(0,"khaki"),this.gradientBody.addColorStop(1,"lightblue")}getCoordinates(){const t=Math.floor(this.pos[0]/this.world.tileSize),e=Math.floor(this.pos[1]/this.world.tileSize);return[t,e]}collision(){const t=[],e=this.getCoordinates(),i=2;for(let o=-i;o<=i;o++)for(let r=-i;r<=i;r++){const[n,l]=c.add(e,[o,r]),h=this.world._getTileEdges(n,l,0);if(h){if(this.world.TileManager._getTileLookupIndex(h,this.world.tileDensityThreshold)===0)continue;const g=this.world.TileManager._lookupTilePathData(h,this.world.tileDensityThreshold).reduce((y,x,m,b)=>{if(x&&x[2]==="iso-start"){const w=c.add(c.multiplyBy([n,l],this.world.tileSize),c.multiplyBy(b[m],this.world.tileSize)),v=c.add(c.multiplyBy([n,l],this.world.tileSize),c.multiplyBy(b[m+1],this.world.tileSize));y.push([w,v])}return y},[]);t.push(...g)}}const s=[];for(const[o,r]of t)try{const[n,l,h]=c.lineCircle(o,r,this.pos,this.radius);n&&s.push([l,h]),this.queue.push(p=>D.renderLine(p,o,r,n?"red":"green",6))}catch(n){console.log("err",n)}if(s.length){const n=s.map((h,p)=>[p,c.distance(this.pos,h[0])]).sort((h,p)=>h[1]-p[1]).slice(0,2).map(([h,p])=>s[h]);this.collisionPoint=c.divideBy(c.addAll(...n.map(h=>h[0])),n.length),this.collisionNormal=c.divideBy(c.addAll(...n.map(h=>h[1])),n.length),this.queue.push(h=>D.renderCircle(h,[...this.collisionPoint],3,"green"));const l=c.subtract(this.collisionPoint,c.multiplyBy(this.collisionNormal,this.radius));if(this.pos[0]=l[0],this.pos[1]=l[1],this.isFalling&&Math.abs(c.len(this.velocity)*this.elasticity)>1.5){const h=c.dot(c.normalize(this.velocity),this.collisionNormal),p=c.len(this.velocity);if(this.velocity=c.multiplyBy(c.reflection(this.velocity,this.collisionNormal),this.elasticity),console.log("bounce",this.velocity,p),p>=10&&h>=.2){this.world.sculpComponent.radiusXY=3;const g=-p*.3*h;console.log("----sculpt strength",g),this.world.sculpComponent.strength=g,this.world.sculpComponent.sculpt(this.collisionPoint)}}else this.velocity[1]=0}else this.collisionNormal=null,this.collisionPoint=null;this.numFramesFalling=s.length?0:this.numFramesFalling+1,s.length?(this.numFramesFalling=0,this.isFalling=!1,this.velocity[0]=this.velocity[0]*this.groundFriction,this.velocity[1]=this.velocity[1]*this.groundFriction):this.numFramesFalling>5&&(this.numFramesFalling++,this.isFalling=!0)}addInput(t){let e=0;if(this.collisionNormal){const o=c.negate(this.collisionNormal),r=[0,-1],n=c.dot(r,o),l=r[0]*o[1]-r[1]*o[0];let h=Math.acos(n)*(180/Math.PI);e=l>0?360-h:h}let i=this.input;this.collisionPoint?(i=c.rotate(this.input,e),i=this.pos[1]>this.collisionPoint[1]?c.negate(i):i,i=c.interp(this.lastActualInput,i,.125)):this.lastActualInput&&(i=c.interp(this.lastActualInput,this.input,.125));const s=this.isFalling?this.airControl:1;this.velocity[0]+=i[0]*this.inputVelocityLength*s*t,this.velocity[1]+=i[1]*this.inputVelocityLength*s*t,this.lastActualInput=i}}class K{constructor(){a(this,"direction");a(this,"mousePos");a(this,"lastMouseMoveEvent");a(this,"_mappings");a(this,"_reverseMappings");a(this,"_inputHandlers");a(this,"register",(t,e,i)=>{this._mappings[t]?(e&&this._mappings[t].listeners.onPress.push(e),i&&this._mappings[t].listeners.onRelease.push(i)):console.error(`The action: ${t} does not exist. Callback could not be registered`)});a(this,"_handleInput",t=>{const e=this._getCurrentInput(t);e&&this._inputHandlers[e.type](t,e)});a(this,"_getCurrentInput",t=>{const e=t.button!==void 0,i=e?"button":"key",s=this._reverseMappings[`${i} ${e?t.button:t.key}`];return this._mappings[s]});a(this,"_handleMouseInput",(t,e)=>{!e.active&&t.type==="mousedown"?e.listeners.onPress.forEach(i=>i(t)):e.active&&t.type==="mouseup"&&e.listeners.onRelease.forEach(i=>i(t)),e.active=t.type==="mousedown"});a(this,"_handleMouseMove",t=>{this.lastMouseMoveEvent=t});a(this,"initListeners",t=>{t.addEventListener("keydown",this._handleInput),t.addEventListener("keyup",this._handleInput),t.addEventListener("mousedown",this._handleInput),t.addEventListener("mouseup",this._handleInput),t.addEventListener("mousemove",this._handleMouseMove)});this.direction=[0,0],this.mousePos=null,this.lastMouseMoveEvent=null,this._mappings={leftMouseButton:{active:!1,type:"mouse",listeners:{onPress:[],onRelease:[]}},rightMouseButton:{active:!1,type:"mouse",listeners:{onPress:[],onRelease:[]}},moveUp:{key:"w",active:!1,type:"action",listeners:{onPress:[],onRelease:[]},direction:[0,-1]},moveLeft:{key:"a",active:!1,type:"action",listeners:{onPress:[],onRelease:[]},direction:[-1,0]},moveDown:{key:"s",active:!1,type:"action",listeners:{onPress:[],onRelease:[]},direction:[0,1]},moveRight:{key:"d",active:!1,type:"action",listeners:{onPress:[],onRelease:[]},direction:[1,0]},jump:{key:" ",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},shift:{key:"Shift",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},dig:{key:"x",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},arrowUp:{key:"arrowUp",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},arrowDown:{key:"arrowDown",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},arrowLeft:{key:"arrowLeft",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},arrowRight:{key:"arrowRight",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}},q:{key:"q",active:!1,type:"action",listeners:{onPress:[],onRelease:[]}}},this._reverseMappings={"button 0":"leftMouseButton","button 1":"rightMouseButton","key w":"moveUp","key a":"moveLeft","key s":"moveDown","key d":"moveRight","key  ":"jump","key Shift":"shift","key x":"dig","key ArrowUp":"arrowUp","key ArrowDown":"arrowDown","key ArrowLeft":"arrowLeft","key ArrowRight":"arrowRight","key q":"q"},this._inputHandlers={mouse:this._handleMouseInput.bind(this),action:this._handleActionInput.bind(this)}}_handleDirectionInput(t,e){e.direction&&(e.active?e.active&&t.type==="keyup"&&(this.direction[0]-=e.direction[0],this.direction[1]-=e.direction[1]):(this.direction[0]+=e.direction[0],this.direction[1]+=e.direction[1]))}_handleActionInput(t,e){e.direction&&this._handleDirectionInput(t,e),e.active?e.active&&t.type==="keyup"&&e.listeners.onRelease.forEach(i=>i(t)):e.listeners.onPress.forEach(i=>i(t)),e.active=t.type==="keydown"}}class O{constructor(t,e=2,i=1){a(this,"worldRef");a(this,"radiusXY");a(this,"strength");a(this,"activeMaterialIndex");a(this,"sculpt",(t,e)=>{const i=c.round(c.divideBy(t,this.worldRef.tileSize)),s=e===void 0?this.activeMaterialIndex:e;for(let h=-this.radiusXY;h<=this.radiusXY;h++)for(let p=-this.radiusXY;p<=this.radiusXY;p++){const g=i[0]+p,y=i[1]+h,x=c.distance(i,[g,y]);if(g<0||y<0||g>this.worldRef.numTilesX||y>this.worldRef.numTilesY)continue;const m=Math.max(Math.min(x/-this.radiusXY+1,1),0),b=this.strength*m,w=s===0?this.worldRef.vertices:this.worldRef.verticesWater,v=w[y][g],M=Math.min(Math.max(0,v+b),this.worldRef.tileDensityMax);if(!(Math.abs(v-M)<=.05)){if(s===0){const C=w[y][g],{tileDensityThreshold:S,tileDensityMax:X}=this.worldRef;this.worldRef.vertices[y][g]=M,b>0?C>S&&(this.worldRef.verticesWater[y][g]=v):(M>S&&(this.worldRef.verticesWater[y][g]=M),C>S&&M<=S&&(this.worldRef.verticesWater[y][g]=S*1.5))}s===1&&this.worldRef.vertices[y][g]<=this.worldRef.tileDensityThreshold&&(this.worldRef.verticesWater[y][g]=M)}}const o=Math.min(Math.max(i[0]-this.radiusXY,0),this.worldRef.numTilesX)-1,r=Math.min(Math.max(i[1]-this.radiusXY,0),this.worldRef.numTilesY)-1,n=Math.min(this.radiusXY*2,this.worldRef.numTilesX)+2,l=Math.min(this.radiusXY*2,this.worldRef.numTilesY)+2;this.worldRef.renderQueue.push({startX:o,startY:r,numTilesX:n,numTilesY:l,terrain:!0,water:!0})});this.worldRef=t,this.radiusXY=e,this.strength=i,this.activeMaterialIndex=0}}class Q{constructor(t,e=!0){a(this,"cachingEnabled");a(this,"cachedPaths");a(this,"getTilePath2D",(t,e,i)=>{if(this.cachingEnabled){const s=this._getTileLookupIndex(t,e);if(s===0)return;const o=s===15?"full-tile":this._getHashKey(t);if(this.cachedPaths.has(o))return this.cachedPaths.get(o);{const r=this._lookupTilePathData(t,e),n=this._createTileSVGPath2D(r,e,i);return this.cachedPaths.set(o,n),n}}else{const s=this._lookupTilePathData(t,e);return this._createTileSVGPath2D(s,e,i)}});a(this,"_getHashKey",t=>`${Math.floor(t[0])}-${Math.floor(t[1])}-${Math.floor(t[2])}-${Math.floor(t[3])}`);a(this,"_createTilePath2D",(t,e,i)=>{const s=this._lookupTilePathData(t,e),o=new Path2D;let r=!1;for(let n=0,l=s.length;n<l;n++)if(s[n]){const h=c.multiplyBy(s[n],i);r?o.lineTo(Math.round(h[0]),Math.round(h[1])):(o.moveTo(Math.round(h[0]),Math.round(h[1])),r=!0)}else r=!1;return o.closePath(),o});a(this,"_createTileSVGPath2D",(t,e,i)=>{let s="",o="",r=!1,n=!1;for(const l of t)if(l){const h=c.multiplyBy(l,i);n?(h[0],h[1],o+=` L ${Math.round(h[0])} ${Math.round(h[1])} Z `,n=!1):Array.isArray(l)&&l[2]==="iso-start"&&(h[0],h[1],o+=`M ${Math.round(h[0])} ${Math.round(h[1])}`,n=!0),r?s+=` L ${Math.round(h[0])} ${Math.round(h[1])} `:(s+=`M ${Math.round(h[0])} ${Math.round(h[1])}`,r=!0)}else s+="Z",r=!1;return[new Path2D(s),new Path2D(o)]});a(this,"inverseLerp",(t,e,i)=>(i-t)/(e-t));this.cachingEnabled=e,this.cachedPaths=new Map}_lookupTilePathData(t,e){const[i,s,o,r]=t,n=this.inverseLerp(i,r,e),l=this.inverseLerp(s,o,e),h=this.inverseLerp(i,s,e),p=this.inverseLerp(r,o,e),g=[[],[[0,n,"iso-start"],[p,1],[0,1],!1],[[p,1,"iso-start"],[1,l],[1,1],!1],[[0,n,"iso-start"],[1,l],[1,1],[0,1],!1],[[1,l,"iso-start"],[h,0],[1,0],!1],[[0,n,"iso-start"],[p,1],[0,1],!1,[1,l,"iso-start"],[h,0],[1,0],!1],[[p,1,"iso-start"],[h,0],[1,0],[1,1],!1],[[h,0,"iso-start"],[0,n],[0,1],[1,1],[1,0],!1],[[h,0,"iso-start"],[0,n],[0,0],!1],[[h,0,"iso-start"],[p,1],[0,1],[0,0],!1],[[0,0],[h,0,"iso-start"],[1,l],[1,1],[p,1,"iso-start"],[0,n],!1],[[0,0],[h,0,"iso-start"],[1,l],[1,1],[0,1],!1],[[0,0],[1,0],[1,l,"iso-start"],[0,n],!1],[[0,0],[1,0],[1,l,"iso-start"],[p,1],[0,1],!1],[[0,0],[1,0],[1,1],[p,1,"iso-start"],[0,n],!1],[[0,0],[1,0],[1,1],[0,1],!1],[[0,n],[0,0],[h,0],!1,[1,l],[1,1],[p,1],!1],[[0,1],[0,n],[h,0],[1,0],[1,l],[p,1],!1]],y=this._getTileLookupIndex([i,s,o,r],e);return g[y]}_getTileLookupIndex(t,e){const[i,s,o,r]=t,n=i>=e?8:0,l=s>=e?4:0,h=o>=e?2:0,p=r>=e?1:0;return n+l+h+p}}class H{static renderDebugGrid(t){const e=t.tileSize*t.numTilesX;for(let s=0;s<=t.numTilesY;s++){const o=s*t.tileSize,r=[0,o],n=[e,o];t.ctx.strokeStyle="grey",t.ctx.fillStyle="grey",t.ctx.lineWidth=.5,D.renderLine(t.ctx,r,n)}const i=t.tileSize*t.numTilesY;for(let s=0;s<=t.numTilesX;s++){const o=s*t.tileSize,r=[o,0],n=[o,i];D.renderLine(t.ctx,r,n)}}static renderDebugEdgeDensity(t,e){const i=e===1?t.vertices:t.verticesWater,s=e===1?"brown":"DodgerBlue";for(let o=0;o<=t.numTilesY;o++)for(let r=0;r<=t.numTilesX;r++){const l=[r*t.tileSize+0+(e?-2:2),o*t.tileSize+0],h=i[o][r];D.renderText(t.ctx,h.toFixed(0),l,e?"right":"left",9,s)}}}class _{constructor(t){a(this,"tileSize");a(this,"numTilesX");a(this,"numTilesY");a(this,"tileDensityMax",128);a(this,"tileDensityThreshold");a(this,"materialColor",[]);a(this,"vertices",[]);a(this,"verticesWater",[]);a(this,"vertMap");a(this,"entities",[]);a(this,"renderQueue",[]);a(this,"debug");a(this,"gradientSky");a(this,"gradientground");a(this,"canvasBackground");a(this,"ctxBackground");a(this,"canvasWater");a(this,"ctxWater");a(this,"canvas");a(this,"ctx");a(this,"canvasCache");a(this,"ctxCache");a(this,"canvasEntity");a(this,"ctxEntity");a(this,"TileManager");a(this,"input");a(this,"sculpComponent");a(this,"last");a(this,"spacialHashSize");a(this,"spacialHash",{});a(this,"main",t=>{const e=this.last?(t-this.last)/1e3:0;this.last=t,this.update(e),this.render(),window.requestAnimationFrame(this.main)});let{tileSize:e,numTilesX:i,numTilesY:s,spacialHashSize:o,fitWindow:r}=t;e=e||32,i=r?Math.floor(window.innerWidth/e)-2:i||32,s=r?Math.floor(window.innerHeight/e)-2:s||32,o=o||3,this.numTilesX=i,this.numTilesY=s,this.spacialHashSize=o;for(let l=0;l<=i;l+=o)for(let h=0;h<=s;h+=o)this.spacialHash[`${l}-${h}`]={startX:l-1,startY:h-1,numTilesX:o+2,numTilesY:o+2,water:!1,terrain:!1};this.debug=!1;const n=document.querySelector(".canvas-container");if(!n)throw new Error("No canvas container found");this.canvasBackground=document.createElement("canvas"),this.canvasBackground.classList.add("canvas-background"),this.canvasBackground.width=e*this.numTilesX,this.canvasBackground.height=e*this.numTilesY,this.canvasBackground.style.zIndex="0",this.ctxBackground=this.canvasBackground.getContext("2d"),n.appendChild(this.canvasBackground),this.canvasWater=document.createElement("canvas"),this.canvasWater.classList.add("canvas-Water"),this.canvasWater.width=e*this.numTilesX,this.canvasWater.height=e*this.numTilesY,this.canvasWater.style.zIndex="2",this.ctxWater=this.canvasWater.getContext("2d"),n.appendChild(this.canvasWater),this.canvas=document.createElement("canvas"),this.canvas.classList.add("canvas-terrain"),this.ctx=this.canvas.getContext("2d"),this.canvas.width=e*this.numTilesX,this.canvas.height=e*this.numTilesY,this.canvas.style.zIndex="3",n.appendChild(this.canvas),this.canvasCache=document.createElement("canvas"),this.canvasCache.width=this.canvas.width,this.canvasCache.height=this.canvas.height,this.ctxCache=this.canvasCache.getContext("2d"),this.canvasEntity=document.createElement("canvas"),this.canvasEntity.width=e*this.numTilesX,this.canvasEntity.height=e*this.numTilesY,this.canvasEntity.style.zIndex="1",this.ctxEntity=this.canvasEntity.getContext("2d"),n.appendChild(this.canvasEntity),this.gradientSky=this.ctx.createLinearGradient(0,0,0,this.canvas.height),this.gradientSky.addColorStop(0,"lightblue"),this.gradientSky.addColorStop(1,"aliceblue"),this.ctxBackground.fillStyle=this.gradientSky,this.ctxBackground.fillRect(0,0,this.canvasBackground.width,this.canvasBackground.height),this.gradientground=this.ctx.createLinearGradient(0,0,0,e),this.gradientground.addColorStop(0,"white"),this.gradientground.addColorStop(.5,"lightblue"),this.gradientground.addColorStop(1,"white"),this.tileSize=e,this.numTilesX=i,this.numTilesY=s,this.tileDensityMax=128,this.tileDensityThreshold=this.tileDensityMax/2,this.materialColor=[this.gradientground,"rgb(30, 144, 255, 0.5)","green","red"],this.vertices=[],this.verticesWater=[],this.vertMap=[this.vertices,this.verticesWater],this.entities=[],this.renderQueue=[{startX:0,startY:0,numTilesX:this.numTilesX,numTilesY:this.numTilesY,terrain:!0,water:!0}],this.TileManager=new Q(e),this.input=new K,this.input.initListeners(document.body),this.sculpComponent=new O(this,1,.3)}_generateVertices(t){for(let e=0;e<=this.numTilesY;e++){const i=[],s=[];for(let o=0;o<=this.numTilesX;o++){const r=t.call(this,o,e);i.push(r),s.push(r>this.tileDensityThreshold?this.tileDensityMax-r:0)}this.vertices.push(i),this.verticesWater.push(s)}}_getTileEdges(t,e,i){try{const s=i===0?this.vertices:this.verticesWater,o=Math.floor(s[e][t]),r=Math.floor(s[e][t+1]),n=Math.floor(s[e+1][t+1]),l=Math.floor(s[e+1][t]);return[o,r,n,l]}catch{return!1}}renderTileAt(t,e,i=null,s=0){const o=i||this._getTileEdges(t,e,s);if(!Array.isArray(o))return;const r=this.TileManager.getTilePath2D(o,this.tileDensityThreshold,this.tileSize),n=s===0?this.ctx:this.ctxWater;if(r&&r[0]){const l=c.multiplyBy([t,e],this.tileSize);n.translate(l[0],l[1]),n.fillStyle=this.materialColor[s],n.fill(r[0]),n.setTransform(1,0,0,1,0,0)}if(r&&r[1]){const l=c.multiplyBy([t,e],this.tileSize);n.translate(l[0],l[1]),n.strokeStyle="black",n.lineCap="butt",n.lineWidth=2,n.stroke(r[1]),n.setTransform(1,0,0,1,0,0)}}rain(){if(Math.random()*100<85)return;const e=[Math.floor(Math.random()*this.canvas.width),0];this.sculpComponent.strength=this.tileDensityThreshold*1.3,this.sculpComponent.radiusXY=1,this.sculpComponent.sculpt(e,1)}getSpacialHashKey(t,e){return`${Math.floor(t/this.spacialHashSize)*this.spacialHashSize}-${Math.floor(e/this.spacialHashSize)*this.spacialHashSize}`}flow(){for(let t=this.numTilesY-1;t>=0;t--){const e=this.verticesWater[t],i=this.verticesWater[t+1],s=this.vertices[t],o=this.vertices[t+1];for(let r=0;r<=this.numTilesX;r++){let n=t%2===0?this.numTilesX-r:r;if(s[n]>=this.tileDensityThreshold)continue;let l=e[n];if(l<=0)continue;const h=i[n]!==void 0?this.tileDensityMax-i[n]:0;if(h&&o[n]<=this.tileDensityThreshold){const m=Math.min(l,h);i[n]+=m,e[n]-=m,this.spacialHash[this.getSpacialHashKey(n,t+1)].water=!0,this.spacialHash[this.getSpacialHashKey(n,t)].water=!0}if(l=e[n],l<=0)continue;if(this.tileDensityMax-e[n-1]&&e[n-1]<l&&s[n-1]<=this.tileDensityThreshold){const m=(l+e[n-1])/2;e[n-1]=m,e[n]=m,this.spacialHash[this.getSpacialHashKey(n-1,t)].water=!0,this.spacialHash[this.getSpacialHashKey(n,t)].water=!0}if(l=e[n],l<=10)continue;if(this.tileDensityMax-e[n+1]&&e[n+1]<l&&s[n+1]<=this.tileDensityThreshold){const m=(l+e[n+1])/2;e[n+1]=m,e[n]=m,this.spacialHash[this.getSpacialHashKey(n+1,t)].water=!0,this.spacialHash[this.getSpacialHashKey(n,t)].water=!0}}}Object.values(this.spacialHash).filter(t=>t.water).forEach(t=>{this.renderQueue.push({...t,water:!0}),t.water=!1})}update(t){if(this.flow(),this.rain(),this.input._mappings.leftMouseButton.active){const e=this.canvas.getBoundingClientRect(),i=this.input.lastMouseMoveEvent;if(!i)return;const s=[i.clientX-e.x,i.clientY-e.y];this.sculpComponent.strength=(this.input._mappings.shift.active?-this.tileDensityThreshold:this.tileDensityThreshold)*.4,this.sculpComponent.radiusXY=3,this.sculpComponent.sculpt(s)}this.entities.forEach(e=>e.update(t))}render(){this.ctxEntity.clearRect(0,0,this.ctxEntity.canvas.width,this.ctxEntity.canvas.height),this.ctx.drawImage(this.canvasCache,0,0),this.renderQueue.length&&(this.renderQueue.forEach(({startX:t,startY:e,numTilesX:i,numTilesY:s,water:o,terrain:r})=>{r&&this.ctx.clearRect(t*this.tileSize,e*this.tileSize,i*this.tileSize,s*this.tileSize),o&&this.ctxWater.clearRect(t*this.tileSize,e*this.tileSize,i*this.tileSize,s*this.tileSize);for(let n=e;n<e+s;n++)for(let l=t;l<t+i;l++)l<0||n<0||l>this.numTilesX||n>this.numTilesY||(r&&this.renderTileAt(l,n,null,0),o&&this.renderTileAt(l,n,null,1))}),this.renderQueue.length=0),this.debug&&(H.renderDebugGrid(this),H.renderDebugEdgeDensity(this,0),H.renderDebugEdgeDensity(this,1)),this.entities.forEach(t=>t.render(this.ctxEntity))}}const J=.5*(Math.sqrt(3)-1),B=(3-Math.sqrt(3))/6,q=f=>Math.floor(f)|0,$=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function V(f=Math.random){const t=Z(f),e=new Float64Array(t).map(s=>$[s%12*2]),i=new Float64Array(t).map(s=>$[s%12*2+1]);return function(o,r){let n=0,l=0,h=0;const p=(o+r)*J,g=q(o+p),y=q(r+p),x=(g+y)*B,m=g-x,b=y-x,w=o-m,v=r-b;let M,C;w>v?(M=1,C=0):(M=0,C=1);const S=w-M+B,X=v-C+B,Y=w-1+2*B,W=v-1+2*B,A=g&255,I=y&255;let P=.5-w*w-v*v;if(P>=0){const k=A+t[I],E=e[k],z=i[k];P*=P,n=P*P*(E*w+z*v)}let L=.5-S*S-X*X;if(L>=0){const k=A+M+t[I+C],E=e[k],z=i[k];L*=L,l=L*L*(E*S+z*X)}let R=.5-Y*Y-W*W;if(R>=0){const k=A+1+t[I+1],E=e[k],z=i[k];R*=R,h=R*R*(E*Y+z*W)}return 70*(n+l+h)}}function Z(f){const e=new Uint8Array(512);for(let i=0;i<512/2;i++)e[i]=i;for(let i=0;i<512/2-1;i++){const s=i+~~(f()*(256-i)),o=e[i];e[i]=e[s],e[s]=o}for(let i=256;i<512;i++)e[i]=e[i-256];return e}const d=new _({tileSize:15,fitWindow:!0,spacialHashSize:3}),F=V(Math.random);d._generateVertices((f,t)=>{const e=F(f/8,t/8)*d.tileDensityMax*.3,i=F(f/16,t/16)*d.tileDensityMax*.5,s=F(f/36,t/36)*d.tileDensityMax*1.25,o=(e+i+s)/3,r=t/d.numTilesY;return Math.max(Math.round(o+d.tileDensityMax*r),0)});document.getElementById("btn-save").onclick=f=>localStorage.setItem("vertMap",JSON.stringify(d.vertMap));document.getElementById("btn-load").onclick=f=>{const t=JSON.parse(localStorage.getItem("vertMap")||"null");t&&(d.vertMap=t,d.vertices=t[0],d.verticesWater=t[1],d.renderQueue.push({startX:0,startY:0,numTilesX:d.numTilesX,numTilesY:d.numTilesY,terrain:!0,water:!0}))};document.getElementById("btn-render").onclick=f=>{d.renderQueue.push({startX:0,startY:0,numTilesX:d.numTilesX,numTilesY:d.numTilesY,terrain:!0,water:!0})};document.getElementById("btn-debug").onclick=f=>{d.debug=!d.debug,d.renderQueue.push({startX:0,startY:0,numTilesX:d.numTilesX,numTilesY:d.numTilesY,terrain:!0,water:!0})};const T=new N(d,[0,0],[d.tileSize*(d.numTilesX/4),0],[0,0]),U=new N(d,[0,0],[d.numTilesX*d.tileSize-d.tileSize*(d.numTilesX/5),0],[0,0]);d.entities.push(T);d.entities.push(U);d.input.register("moveLeft",()=>T.input=c.add(T.input,d.input._mappings.moveLeft.direction),()=>T.input=c.subtract(T.input,d.input._mappings.moveLeft.direction));d.input.register("moveRight",()=>T.input=c.add(T.input,d.input._mappings.moveRight.direction),()=>T.input=c.subtract(T.input,d.input._mappings.moveRight.direction));d.input.register("q",()=>T.mode=T.mode==="dig"?"normal":"dig");d.input.register("arrowUp",()=>d.sculpComponent.activeMaterialIndex=1);d.input.register("arrowDown",()=>d.sculpComponent.activeMaterialIndex=0);requestAnimationFrame(d.main);

</script>
</head>

<body>
<div class="canvas-container"></div>

<div class="debug-buttons">
    <button id="btn-save">save</button>
    <button id="btn-load">load</button>
    <button id="btn-render">render</button>
    <button id="btn-debug">toggle-debug</button>
</div>

</body>



</html>
